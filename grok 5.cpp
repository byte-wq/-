// grok 5.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>     // ввод / вывод
#include <queue>        // очередь для BFS
#include <map>          // словари (комната -> данные)
#include <vector>       // хранение списка соседей
#include <algorithm>    // reverse()

using namespace std;

int main() {
    setlocale(LC_ALL, "Russian");
    // Граф лабиринта:
    // ключ — комната, значение — список комнат, куда можно пойти
    map<char, vector<char>> g;

    // Лямбда-функция для добавления двустороннего прохода
    // (если можно пройти из A в B, то и из B в A)
    auto addEdge = [&](char a, char b) {
        g[a].push_back(b);
        g[b].push_back(a);
        };

    // Описание лабиринта (проходы между комнатами) 
    // Стартовая зона
    addEdge('S', 'A');
    addEdge('S', 'E');
    addEdge('S', 'B');

    // Левая часть лабиринта
    addEdge('A', 'F');
    addEdge('E', 'F');

    // Центральная часть
    addEdge('E', 'D');
    addEdge('D', 'B');
    addEdge('D', 'G');

    // Верхняя часть
    addEdge('G', 'H');
    addEdge('G', 'I');

    // Правая часть
    addEdge('B', 'C');
    addEdge('C', 'J');
    addEdge('J', 'I');
 

    char start = 'S';   // вход в лабиринт
    char finish = 'I';  // выход из лабиринта

    queue<char> q;          // очередь для BFS
    map<char, bool> used;   // массив посещённых комнат
    map<char, char> parent; // откуда пришли в каждую комнату

    // Инициализация BFS
    used[start] = true; // помечаем старт как посещённый
    parent[start] = 0;  // у стартовой комнаты нет родителя
    q.push(start);      // добавляем старт в очередь

    // Основной цикл BFS
    while (!q.empty()) {
        char v = q.front(); // берём первую комнату из очереди
        q.pop();            // удаляем её из очереди

        // Если дошли до выхода — дальше можно не искать
        if (v == finish) break;

        // Проходим по всем соседям текущей комнаты
        for (char to : g[v]) {
            // Если сосед ещё не был посещён
            if (!used[to]) {
                used[to] = true;    // отмечаем как посещённый
                parent[to] = v;     // запоминаем, откуда пришли
                q.push(to);         // добавляем в очередь
            }
        }
    }

    // Если выход не был достигнут
    if (!used[finish]) {
        cout << "Путь не найден\n";
        return 0;
    }

    //  Восстановление кратчайшего пути
    vector<char> path;

    // Идём от финиша к старту по массиву parent
    for (char v = finish; v != 0; v = parent[v]) {
        path.push_back(v);
    }

    // Разворачиваем путь, так как шли с конца
    reverse(path.begin(), path.end());

    // Вывод результата 
    cout << "Кратчайший путь найден\n";
    cout << "Длина пути: " << path.size() - 1 << "\n"; // количество переходов

    cout << "Путь: ";
    for (int i = 0; i < path.size(); i++) {
        cout << path[i];
        if (i + 1 < path.size()) cout << " -> ";
    }
    cout << endl;

    return 0;
}


// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
